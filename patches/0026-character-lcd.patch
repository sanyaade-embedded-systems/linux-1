Index: primus-kernel/drivers/char/omapl1x7_lcd/Makefile
===================================================================
--- /dev/null
+++ primus-kernel/drivers/char/omapl1x7_lcd/Makefile
@@ -0,0 +1,10 @@
+#
+# Makefile for the Linux lcd driver.
+#
+
+obj-$(CONFIG_OMAPL1X7_LCD) += omapl1x7_lcd.o
+
+omapl1x7_lcd-objs := lcd_drv.o  lidd_hal.o  hd44780_hal.o
+
+omapl1x7_lcd.o:      $(omapl1x7_lcd-objs)
+	$(LD) -r -o $@ $(omapl1x7_lcd-objs)
Index: primus-kernel/drivers/char/Kconfig
===================================================================
--- primus-kernel.orig/drivers/char/Kconfig
+++ primus-kernel/drivers/char/Kconfig
@@ -1101,5 +1101,13 @@ config DEVPORT
 
 source "drivers/s390/char/Kconfig"
 
+config  OMAPL1X7_LCD
+	tristate "OMAPL1X7 Character LCD Support"
+	default n
+	depends on MACH_OMAPL1X7_EVM && !FB_OMAPL1X7
+	help
+	  OMAPL1X7 Character LCD support.
+
+
 endmenu
 
Index: primus-kernel/drivers/char/omapl1x7_lcd/hd44780_hal.c
===================================================================
--- /dev/null
+++ primus-kernel/drivers/char/omapl1x7_lcd/hd44780_hal.c
@@ -0,0 +1,209 @@
+/*
+ * Copyright (C) 2008 MontaVista Software Inc.
+ * Copyright (C) 2008 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+/*
+ * A single HD47780 can be set in the following modes.
+ *
+ *  8 x 1, 16 x 1, 16 x 2, 16 x 4, 20 x 1, 20 x 2, 20 X 4, 24 x 1, 24 x 2
+ *
+ * Different display set up affects the way we deal with the data location
+ * in the intenal data buffer (i.e. address in the data buffer).
+ *
+ */
+
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include "hd44780_hal.h"
+#include "lidd_cmd.h"
+
+struct hd47780 {
+	unsigned int cntl_reg;
+	unsigned int data_reg;
+	unsigned char disp_row;
+	unsigned char disp_col;
+	unsigned char disp_cntl;
+	unsigned char entry_mode;
+};
+
+static int hd47780_p_set_to_xy(struct hd47780 *p, int x, int y);
+
+static inline void lidd_udelay(unsigned int delay, unsigned int addr)
+{
+	unsigned int i, val;
+	for (i = 0; i < delay; i++) {
+		val = readl(addr);
+		if (!(val & HD47780_BUSY))
+			break;
+		udelay(1);
+	}
+}
+
+int hd47780_p_set_to_xy(struct hd47780 *p, int x, int y)
+{
+	unsigned int cursor_offset = x + (y % 2) * HD47780_ROW_SIZE;
+	if (p->disp_row == 1)
+		cursor_offset += (x % 8) * (HD47780_ROW_SIZE - 8);
+						/* reqd for 1x16 */
+	if ((y % 4) >= 2)
+		cursor_offset += p->disp_col;
+
+	/* load this offset into the lcd. */
+	writel(cursor_offset | 0x80, p->cntl_reg);
+	lidd_udelay(50, p->cntl_reg);
+
+	return 0;
+}
+
+struct hd47780 *hd47780_init(unsigned int cntl_reg,
+			     unsigned int data_reg,
+			     unsigned char disp_row, unsigned char disp_col)
+{
+	struct hd47780 *p_hd = NULL;
+	char func_set = 0x20;
+
+	p_hd = kzalloc(sizeof(struct hd47780), GFP_KERNEL);
+	if (!p_hd)
+		return NULL;
+	p_hd->cntl_reg = cntl_reg;
+	p_hd->data_reg = data_reg;
+	p_hd->disp_row = disp_row;
+	p_hd->disp_col = disp_col;
+
+	if (!(p_hd->disp_row % 2))
+		func_set |= 0x08;
+
+	lidd_udelay(200, p_hd->cntl_reg);
+
+	if (readl(p_hd->cntl_reg) & HD47780_BUSY) {
+		kfree(p_hd);
+		return 0;
+	}
+
+	writel(func_set | 0x10, p_hd->cntl_reg);
+	lidd_udelay(50, p_hd->cntl_reg);
+
+	return p_hd;
+}
+
+int hd47780_cleanup(struct hd47780 *p_obj)
+{
+	kfree(p_obj);
+	return 0;
+}
+
+int hd47780_ioctl(struct hd47780 *p_obj, unsigned int cmd, unsigned int val)
+{
+	switch (cmd) {
+	case LIDD_CLEAR_SCREEN:
+		writel(HD47780_CLR_SCR, p_obj->cntl_reg);
+		lidd_udelay(2000, p_obj->cntl_reg);
+		break;
+
+	case LIDD_CURSOR_HOME:
+		writel(HD47780_DRAM_0, p_obj->cntl_reg);
+		lidd_udelay(2000, p_obj->cntl_reg);
+		break;
+
+	case LIDD_GOTO_XY:
+		hd47780_p_set_to_xy(p_obj, (val & 0xff00) >> 8, (val & 0xff));
+		break;
+
+	case LIDD_DISPLAY:
+		if (val)
+			p_obj->disp_cntl |= HD47780_DISP_ON;
+		else
+			p_obj->disp_cntl &= ~HD47780_DISP_ON;
+		writel(p_obj->disp_cntl | HD47780_SET_DCB, p_obj->cntl_reg);
+		lidd_udelay(50, p_obj->cntl_reg);
+		break;
+
+	case LIDD_BLINK:	/* Blink ON/OFF */
+		if (val)
+			p_obj->disp_cntl |= HD47780_BLINK_ON;
+		else
+			p_obj->disp_cntl &= ~HD47780_BLINK_ON;
+		writel(p_obj->disp_cntl | HD47780_SET_DCB, p_obj->cntl_reg);
+		lidd_udelay(50, p_obj->cntl_reg);
+		break;
+
+	case LIDD_CURSOR_STATE:	/* Cursor State ON/OFF */
+		if (val)
+			p_obj->disp_cntl |= HD47780_CURSOR_ON;
+		else
+			p_obj->disp_cntl &= ~HD47780_CURSOR_ON;
+		writel(p_obj->disp_cntl | HD47780_SET_DCB, p_obj->cntl_reg);
+		lidd_udelay(50, p_obj->cntl_reg);
+		break;
+
+	case LIDD_DISPLAY_SHIFT:	/* controls whether display
+					   will be shifted when
+					   characters are read/written */
+		if (val)
+			p_obj->entry_mode |= HD47780_SHIFT_ON;
+		else
+			p_obj->entry_mode &= ~HD47780_SHIFT_ON;
+		writel(p_obj->entry_mode | HD47780_SET_IDS, p_obj->cntl_reg);
+		lidd_udelay(50, p_obj->cntl_reg);
+		break;
+
+	case LIDD_CURSOR_SHIFT:
+		if (val)
+			p_obj->entry_mode |= HD47780_CSR_INC;
+		else
+			p_obj->entry_mode &= ~HD47780_CSR_INC;
+		writel(p_obj->entry_mode | HD47780_SET_IDS, p_obj->cntl_reg);
+		lidd_udelay(50, p_obj->cntl_reg);
+		break;
+
+	case LIDD_CURSOR_MOVE:
+		if (val)
+			val = HD47780_RGHT_DIR;
+		writel(val | HD47780_SET_SCRL, p_obj->cntl_reg);
+		lidd_udelay(50, p_obj->cntl_reg);
+		break;
+
+	case LIDD_DISPLAY_MOVE:	/* moves the display LEFT/RIGHT */
+		if (val)
+			val = HD47780_RGHT_DIR;
+		writel(val | HD47780_DISP_MOV, p_obj->cntl_reg);
+		lidd_udelay(50, p_obj->cntl_reg);
+		break;
+
+	case LIDD_WR_CHAR:
+		writeb((char)val, p_obj->data_reg);
+		lidd_udelay(50, p_obj->cntl_reg);
+		break;
+
+	case LIDD_RD_CHAR:
+		*((unsigned char *)val) = readb(p_obj->data_reg);
+		lidd_udelay(50, p_obj->cntl_reg);
+		break;
+
+	case LIDD_RD_CMD:
+		*((unsigned int *)val) = readl(p_obj->cntl_reg);
+		break;
+
+	default:
+		break;
+
+	}
+
+	return 0;
+}
Index: primus-kernel/drivers/char/omapl1x7_lcd/hd44780_hal.h
===================================================================
--- /dev/null
+++ primus-kernel/drivers/char/omapl1x7_lcd/hd44780_hal.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2008 MontaVista Software Inc.
+ * Copyright (C) 2008 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#define _HD47780_HAL_H_
+
+#define HD47780_CLR_SCR    0x1  /* Clears entire display */
+#define HD47780_DRAM_0     0x2  /* Sets DRAM address 0 in address counter */
+
+#define HD47780_SET_IDS    0x4  /* Cursor move direction, display Shift setup */
+#define HD47780_SHIFT_ON   0x1  /* Sets display shift */
+#define HD47780_CSR_INC    0x2  /* Sets cursor move direction to Increment */
+
+#define HD47780_SET_DCB    0x8  /* ON/OFF setup for display, cursor and blink*/
+#define HD47780_BLINK_ON   0x1  /* Sets blink ON */
+#define HD47780_CURSOR_ON  0x2  /* Sets cursor ON */
+#define HD47780_DISP_ON    0x4  /* Sets display ON */
+
+#define HD47780_SET_SCRL  0x10  /* Cursor move and display move setup */
+#define HD47780_DISP_MOV  0x18  /* Selects display move mode */
+#define HD47780_RGHT_DIR   0x4  /* Selects disp. shift/cursor move to right */
+
+#define HD47780_BUSY      0x80  /* Busy flag - internal operation in progress */
+
+#define HD47780_ROW_SIZE  0x40  /* Bytes per row in DDRAM */
+/**********************************************************************
+ * Returns: NULL in case of error, otherwise a handle to be used in sub-
+ * sequent calls.
+ *********************************************************************/
+struct hd47780 *hd47780_init(unsigned int cntl_reg,
+			     unsigned int data_reg,
+			     unsigned char row,
+			     unsigned char col);
+
+/**********************************************************************
+ * Returns: -1 for error otherwise 0 for success.
+ *********************************************************************/
+int hd47780_cleanup(struct hd47780 *p);
+
+/**********************************************************************
+ * Returns: -1 for error, other 0 for success.
+ *
+ *     cmd                                  val
+ *
+ *     LIDD_CLEAR_SCREEN                 none
+ *     LIDD_CURSOR_HOME                  none
+ *     LIDD_DISPLAY                      0 - off, 1 - on
+ *     LIDD_GOTO_XY                      [row - 2 bytes][col - 2 bytes]
+ *     LIDD_BLINK                        0 - off, 1 - on
+ *     LIDD_CURSOR_STATE                 0 - not visible, 1 - visible.
+ *     LIDD_SHIFT                        1 - Right shift, 0 - left shift.
+ *     LIDD_CURSOR_SHIFT                 1 - Right, 0 - left
+ *     LIDD_WR_CHAR                      character.
+ *     LIDD_RD_CHAR                      place holder for character.
+ *     LIDD_CURSOR_MOVE                  1 - Right, 0 - Left
+ *     LIDD_DISPLAY_MOVE                 1 - Right, 0 - Left.
+ *     LIDD_LINE_WRAP                    0 - off, 1 - on.
+ *
+ *********************************************************************/
+int hd47780_ioctl(struct hd47780 *p, unsigned int cmd, unsigned int val);
Index: primus-kernel/drivers/char/omapl1x7_lcd/lcd.h
===================================================================
--- /dev/null
+++ primus-kernel/drivers/char/omapl1x7_lcd/lcd.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2008 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _LCD_H_
+#define _LCD_H_
+#define DEFAULT_ROWS 2		/*HANTRONIX HDM24216-2*/
+#define DEFAULT_COLS 24		/*HANTRONIX HDM24216-2*/
+#define MAX_ROWS 4
+#define MAX_COLS 48
+
+struct lcd_pos_arg {
+	u32 row;
+	u32 column;
+};
+
+#endif
Index: primus-kernel/drivers/char/omapl1x7_lcd/lcd_drv.c
===================================================================
--- /dev/null
+++ primus-kernel/drivers/char/omapl1x7_lcd/lcd_drv.c
@@ -0,0 +1,417 @@
+/*
+ * Copyright (C) 2008 MontaVista Software Inc.
+ * Copyright (C) 2008 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+/*******************************************************************************
+ * FILE PURPOSE:    LCD Module Driver Source
+ *******************************************************************************
+ * FILE DESCRIPTION:     Source code for Linux LCD Driver
+ *
+ * REVISION HISTORY:
+ *
+ * Date           Description                               Author
+ *-----------------------------------------------------------------------------
+ * 27 Aug 2003    Initial Creation                          Sharath Kumar
+ *
+ * 16 Dec 2003    Updates for 5.7                           Sharath Kumar
+ *
+ * (C) Copyright 2003, Texas Instruments, Inc
+ ******************************************************************************/
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/mm.h>
+#include <linux/version.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <asm/system.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/i2c.h>
+#include "lcd.h"
+
+#include <linux/moduleparam.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <mach/omapl1x7_lcdc.h>
+#include "lidd_hal.h"
+
+#define    LCD_VERSION                 "0.2"
+#define    MAX_LCD_SIZE                 ((MAX_ROWS)*(MAX_COLS))
+
+/* LCD seek origin positions*/
+#define  SEEK_CUR    1
+#define  SEEK_END    2
+#define  SEEK_SET    0
+
+#define OMAPL1X7_LCD_NAME "lcd_omapl1x7"
+
+struct lcd_dev {
+	void *hal_handle;
+	char devname[10];
+	struct semaphore sem;
+	int rows;
+	int columns;
+	struct resource *lcd_res;
+	struct clk *clk;
+};
+
+static struct lcd_dev *lcd_dev;
+static int rows = DEFAULT_ROWS;
+static int columns = DEFAULT_COLS;
+
+static ssize_t tilcd_read(struct file *file, char *buf,
+			  size_t count, loff_t *ppos)
+{
+	struct lcd_dev *lcd_dev = file->private_data;
+	int ret = -1, max = lcd_dev->columns * lcd_dev->rows;
+	char temp_buf[MAX_LCD_SIZE];
+	int x_pos, y_pos;
+
+	if (*ppos >= max)
+		return 0;
+
+	memset(temp_buf, 0, max);
+
+	/* Limit the count to max LCD size if it is greater than that */
+	count = (count > max) ? max : count;
+
+	if (down_interruptible(&lcd_dev->sem))
+		return -ERESTARTSYS;
+
+	/* syncing file offset and cursor position */
+	x_pos = ((long)*ppos) / lcd_dev->columns;
+	y_pos = ((long)*ppos) % lcd_dev->columns;
+	ti_lidd_hal_ioctl(lcd_dev->hal_handle, LIDD_GOTO_XY, (y_pos << 8) |
+			  x_pos);
+
+	ret = ti_lidd_hal_read(lcd_dev->hal_handle, temp_buf, count);
+
+	if (ret > 0) {
+		if (copy_to_user(buf, temp_buf, ret))
+			ret = -EFAULT;
+	}
+
+	if (ret >= 0) {
+		*ppos += ret;
+
+		/* syncing file offset and cursor position */
+		x_pos = ((long)*ppos) / lcd_dev->columns;
+		y_pos = ((long)*ppos) % lcd_dev->columns;
+		ti_lidd_hal_ioctl(lcd_dev->hal_handle, LIDD_GOTO_XY,
+				  (y_pos << 8) | x_pos);
+	}
+
+	up(&lcd_dev->sem);
+	return ret;
+}
+
+static ssize_t tilcd_write(struct file *file, const char *buf,
+			   size_t count, loff_t *ppos)
+{
+	struct lcd_dev *lcd_dev = file->private_data;
+	int ret = -1, max = lcd_dev->columns * lcd_dev->rows;
+	char temp_buf[MAX_LCD_SIZE];
+	int x_pos, y_pos;
+
+	if (down_interruptible(&lcd_dev->sem))
+		return -ERESTARTSYS;
+
+	/* Limit the count to max LCD size if it is greater than that */
+	count = (count > max) ? max : count;
+
+	/* syncing file offset and cursor position */
+	x_pos = ((long)*ppos) / lcd_dev->columns;
+	y_pos = ((long)*ppos) % lcd_dev->columns;
+	ti_lidd_hal_ioctl(lcd_dev->hal_handle, LIDD_GOTO_XY, (y_pos << 8) |
+			  x_pos);
+
+	if (copy_from_user(temp_buf, buf, count))
+		ret = -EFAULT;
+	else
+		ret = ti_lidd_hal_write(lcd_dev->hal_handle, temp_buf, count);
+
+	if (ret >= 0) {
+		*ppos += ret;
+
+		/* syncing file offset and cursor position */
+		x_pos = (((long)*ppos) / lcd_dev->columns);
+		y_pos = ((long)*ppos) % lcd_dev->columns;
+		ti_lidd_hal_ioctl(lcd_dev->hal_handle, LIDD_GOTO_XY,
+				  (y_pos << 8) | x_pos);
+	}
+
+	up(&lcd_dev->sem);
+	return ret;
+}
+
+static int tilcd_ioctl(struct inode *inode, struct file *file,
+		       unsigned int cmd, unsigned long arg)
+{
+	struct lcd_dev *lcd_dev = file->private_data;
+	int ret = 0;
+	struct lcd_pos_arg lcd_pos;
+	unsigned long hal_arg = arg;
+	unsigned int read_val;
+
+	if (down_interruptible(&lcd_dev->sem))
+		return -ERESTARTSYS;
+
+	if (cmd == LIDD_GOTO_XY) {
+		if (copy_from_user
+		    (&lcd_pos, (char *)arg, sizeof(struct lcd_pos_arg)))
+			ret = -EFAULT;
+		/* syncing file offset and cursor position */
+		file->f_pos = lcd_pos.row * lcd_dev->columns + lcd_pos.column;
+		hal_arg = lcd_pos.row | (lcd_pos.column << 8);
+	}
+
+	/* The commands below require something to be written to user buffer */
+	if (cmd == LIDD_RD_CMD || cmd == LIDD_RD_CHAR)
+		hal_arg = (unsigned long)&read_val;
+
+	ret = ti_lidd_hal_ioctl(lcd_dev->hal_handle, cmd, hal_arg);
+
+	switch (cmd) {
+	case LIDD_RD_CMD:
+	case LIDD_RD_CHAR:
+		if (copy_to_user((char *)arg, &read_val, sizeof(int)))
+			ret = -EFAULT;
+		break;
+
+	default:
+		break;
+	}
+
+	up(&lcd_dev->sem);
+	return ret;
+}
+
+static int tilcd_open(struct inode *inode, struct file *file)
+{
+	/* Set the private data. cannot be done in init through cdev */
+	file->private_data = lcd_dev;
+
+	ti_lidd_hal_open(lcd_dev->hal_handle);
+
+	return 0;
+}
+
+static int tilcd_release(struct inode *inode, struct file *file)
+{
+	ti_lidd_hal_close(lcd_dev->hal_handle);
+	return 0;
+}
+
+static loff_t tilcd_lseek(struct file *file, loff_t offset, int orig)
+{
+
+	struct lcd_dev *lcd_dev = file->private_data;
+	int max = lcd_dev->columns * lcd_dev->rows;
+	int x_pos, y_pos;
+
+	if (down_interruptible(&lcd_dev->sem))
+		return -ERESTARTSYS;
+
+	switch (orig) {
+	case SEEK_END:
+		offset += max;
+		break;
+
+	case SEEK_CUR:
+		offset += file->f_pos;
+	case SEEK_SET:
+		break;
+
+	default:
+		up(&lcd_dev->sem);
+		return -EINVAL;
+	}
+
+	offset = (long)offset % (long)max;
+
+	file->f_pos = offset;
+
+	x_pos = (((long)offset) / lcd_dev->columns);
+	y_pos = ((long)offset) % lcd_dev->columns;
+	ti_lidd_hal_ioctl(lcd_dev->hal_handle, LIDD_GOTO_XY, (y_pos << 8) |
+			  x_pos);
+
+	up(&lcd_dev->sem);
+	return file->f_pos;
+}
+
+struct file_operations tilcd_fops = {
+	.owner = THIS_MODULE,
+	.read = tilcd_read,
+	.write = tilcd_write,
+	.ioctl = tilcd_ioctl,
+	.open = tilcd_open,
+	.release = tilcd_release,
+	.llseek = tilcd_lseek
+};
+
+static struct miscdevice omapl1x7_lcd_miscdev = {
+	.minor = 0,
+	.name = OMAPL1X7_LCD_NAME,
+	.fops = &tilcd_fops,
+};
+
+static int __devinit omapl1x7_lcd_probe(struct platform_device *device)
+{
+	struct ti_lidd_info lcd_info;
+	struct resource *lcdc_regs;
+	struct omapl1x7_lcdc_platform_data *lcd_pdata =
+						device->dev.platform_data;
+	int ret = 0;
+
+	if (omapl1x7_lcd_hw_init()) {
+		printk(KERN_ALERT "Error in Initialising\n");
+		return -ENODEV;
+	}
+
+	if (lcd_pdata == NULL) {
+		dev_err(&device->dev, "Can not get platform data\n");
+		return -ENOENT;
+	}
+
+	lcd_dev = kzalloc(sizeof(struct lcd_dev), GFP_KERNEL);
+	if (!lcd_dev) {
+		dev_err(&device->dev, "Can't allocate memory for device\n");
+		return -ENOMEM;
+	}
+
+	lcdc_regs = platform_get_resource(device, IORESOURCE_MEM, 0);
+	if (!lcdc_regs) {
+		dev_err(&device->dev,
+			"Can not get memory resource for LCD controller\n");
+		ret = -ENOENT;
+		goto err_get_resource;
+	}
+
+	lcd_dev->lcd_res = request_mem_region(lcdc_regs->start,
+					      lcdc_regs->end -
+					      lcdc_regs->start + 1,
+					      device->name);
+	if (lcd_dev->lcd_res == NULL) {
+		dev_err(&device->dev, "Request memory for registers failed\n");
+		ret = -ENOENT;
+		goto err_get_resource;
+	}
+
+	lcd_info.base_addr = IO_ADDRESS(lcdc_regs->start);
+	lcd_dev->clk = clk_get(&device->dev, lcd_pdata->lcdc_clk_name);
+	if (IS_ERR(lcd_dev->clk)) {
+		printk(KERN_ERR "Can not get LCD clock\n");
+		ret = -ENOENT;
+		goto err_clk_get;
+	}
+	clk_enable(lcd_dev->clk);
+	lcd_dev->rows = lcd_info.disp_row = rows;
+	lcd_dev->columns = lcd_info.disp_col = columns;
+	lcd_info.line_wrap = 1;
+	lcd_info.cursor_blink = 1;
+	lcd_info.cursor_show = 1;
+	lcd_info.lcd_type = 4;	/* HITACHI */
+	lcd_info.num_lcd = 1;
+
+	lcd_dev->hal_handle = ti_lidd_hal_init(&lcd_info);
+	if (!lcd_dev->hal_handle) {
+		printk(KERN_ERR "LCD: hal not initialized\n");
+		ret = -EIO;
+		goto err_hal_init;
+	}
+
+	sprintf(lcd_dev->devname, OMAPL1X7_LCD_NAME);
+
+	ret = misc_register(&omapl1x7_lcd_miscdev);
+	if (ret < 0) {
+		printk(KERN_ERR "LCD: misc_register failed\n");
+		ret = -EIO;
+		goto err_misc_register;
+	}
+
+	sema_init(&lcd_dev->sem, 1);
+
+	platform_set_drvdata(device, lcd_dev);
+
+	return 0;
+
+err_misc_register:
+	ti_lidd_hal_cleanup(lcd_dev->hal_handle);
+err_hal_init:
+	clk_disable(lcd_dev->clk);
+	clk_put(lcd_dev->clk);
+err_clk_get:
+	release_resource(lcd_dev->lcd_res);
+err_get_resource:
+	kfree(lcd_dev);
+	return ret;
+}
+
+static int omapl1x7_lcd_remove(struct platform_device *dev)
+{
+	misc_deregister(&omapl1x7_lcd_miscdev);
+	ti_lidd_hal_cleanup(lcd_dev->hal_handle);
+	clk_disable(lcd_dev->clk);
+	clk_put(lcd_dev->clk);
+	release_resource(lcd_dev->lcd_res);
+	kfree(lcd_dev);
+	return 0;
+}
+
+static struct platform_driver omapl1x7_lcd_driver = {
+	.probe	= omapl1x7_lcd_probe,
+	.remove = omapl1x7_lcd_remove,
+	.driver = {
+		   .name = "omapl1x7_lcdc",
+		   .owner = THIS_MODULE,
+	},
+};
+
+static int __init omapl1x7_lcd_init(void)
+{
+	return platform_driver_register(&omapl1x7_lcd_driver);
+}
+
+static void __exit omapl1x7_lcd_cleanup(void)
+{
+	platform_driver_unregister(&omapl1x7_lcd_driver);
+}
+
+module_init(omapl1x7_lcd_init);
+module_exit(omapl1x7_lcd_cleanup);
+
+module_param(rows, int, 0);
+module_param(columns, int, 0);
+
+MODULE_DESCRIPTION("Driver for TI CHARACTER LCD");
+MODULE_AUTHOR("Maintainer: Sharath Kumar <krs@ti.com>");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(LCD_VERSION);
Index: primus-kernel/drivers/char/omapl1x7_lcd/lidd_hal.c
===================================================================
--- /dev/null
+++ primus-kernel/drivers/char/omapl1x7_lcd/lidd_hal.c
@@ -0,0 +1,436 @@
+/*
+ * Copyright (C) 2008 MontaVista Software Inc.
+ * Copyright (C) 2008 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+/**************************************************************************
+ * FILE PURPOSE :   HAL code for LCD LIDD controller.
+ **************************************************************************
+ *
+ *  FILE DESCRIPTION  :
+ *  HAL code for LCD LIDD controller.
+ *
+ *************************************************************************/
+
+#include <linux/slab.h>
+#include "hd44780_hal.h"
+#include "lidd_hal.h"
+
+struct ti_lidd_regs {
+	unsigned int config;
+	unsigned int addr;
+	unsigned int data;
+};
+
+struct ti_lcd_cntl_regs {
+	unsigned int revision;
+	unsigned int cntl;
+	unsigned int status;
+	unsigned int lidd_cntl;
+	struct ti_lidd_regs cs[2];
+	unsigned int raster_cntl;
+	unsigned int raster_timing_0;
+	unsigned int raster_timing_1;
+	unsigned int raster_timing_2;
+	unsigned int subpanel_disp;
+	unsigned int reserved;
+	unsigned int dma_cntl;
+	unsigned int frame0_base_addr;
+	unsigned int frame0_ceiling;
+	unsigned int frame1_base_addr;
+	unsigned int frame1_ceiling;
+};
+
+struct lidd_hal_obj {
+	unsigned char num_lcd_inst;
+	void *lcd_inst[2];
+	struct ti_lcd_cntl_regs *regs;
+	unsigned int active_inst;
+	unsigned int disp_row;
+	unsigned int disp_col;
+	unsigned int line_wrap;
+	unsigned int cursor_state;
+	unsigned int cursor_shift;
+	unsigned int row;
+	unsigned int col;
+
+};
+
+static int ti_lidd_p_set_to_xy(struct lidd_hal_obj *, int, int);
+static int ti_lidd_p_update_properties(struct lidd_hal_obj *);
+static int ti_lidd_p_lwrap_cursor_move(struct lidd_hal_obj *,
+				       unsigned int direction);
+static int ti_lidd_p_wr_or_rd(struct lidd_hal_obj *, unsigned int cmd,
+			      unsigned int data);
+
+/*-----------------------------------------------------------------------------
+ * Updates the properties of the LCD.
+ *
+ * Returns 0 on success or -1 on failure.
+ *---------------------------------------------------------------------------*/
+int ti_lidd_p_update_properties(struct lidd_hal_obj *p)
+{
+	unsigned int passive_inst = !p->active_inst;
+
+	if (p->num_lcd_inst > 1)
+		hd47780_ioctl(p->lcd_inst[passive_inst],
+			      LIDD_CURSOR_STATE, p->cursor_state);
+
+	hd47780_ioctl(p->lcd_inst[p->active_inst], LIDD_CURSOR_STATE,
+		      p->cursor_state);
+
+	return 0;
+}
+
+/*---------------------------------------------------------
+ * Sets the cursor at the specified location.
+ * x is the column, y is the row.
+ *
+ * Returns 0 on success otherwise -1.
+ *-------------------------------------------------------*/
+int ti_lidd_p_set_to_xy(struct lidd_hal_obj *p, int x, int y)
+{
+	int update = 0;
+
+	if (p->line_wrap) {
+		/* wrap the row and col if required. */
+		p->col = x = x % p->disp_col;
+		p->row = y = y % p->disp_row;
+	}
+
+	/* Figure out if this causes a moving to lcd 0 to lcd 1. */
+	if ((p->num_lcd_inst == 2) && (y > p->disp_row / 2 - 1)) {
+		y = y % 2;
+
+		if (p->active_inst == 0)
+			update = 1;
+
+		p->active_inst = 1;
+	} else {
+		/* Figure out if this causes a moving to lcd 1 to lcd 0. */
+		if (p->active_inst == 1)
+			update = 1;
+
+		p->active_inst = 0;
+	}
+
+	if (update)
+		ti_lidd_p_update_properties(p);
+
+	hd47780_ioctl(p->lcd_inst[p->active_inst], LIDD_GOTO_XY, x << 8 | y);
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ * Wraps a line i.e. when the last of column of the row is reached, the cursor
+ * is moved to the next row, first col. When the last row and last col is
+ *  reached the cursor is moved to the first row.
+ *
+ * Returns: 0 if now wrap was done. 1, if a wrap was carried out.
+ *---------------------------------------------------------------------------*/
+int ti_lidd_p_lwrap_cursor_move(struct lidd_hal_obj *p, unsigned int direction)
+{
+	int ret_val = 0;
+
+	if (direction) {	/* move right. */
+		p->col = (++p->col) % (p->disp_col);
+		if (!p->col) {
+			/* line wrapped. */
+			p->row = (++p->row) % p->disp_row;
+
+			/* Indicate the lcd of the line wrapping. */
+			ti_lidd_p_set_to_xy(p, p->col, p->row);
+
+			ret_val = 1;
+		}
+	} else {		/* move left. */
+
+		if (!p->col) {
+			/* line wrapped. */
+			p->col = p->disp_col - 1;
+			p->row = (!p->row) ? p->disp_row - 1 : --p->row;
+
+			/* Indicate the lcd of the line wrapping. */
+			ti_lidd_p_set_to_xy(p, p->col, p->row);
+
+			ret_val = 1;
+		} else {
+			p->col--;
+		}
+	}
+	return ret_val;
+}
+
+/*-----------------------------------------------------------------------------
+ * Writes or reads a character to/from LCD.
+ *
+ * Returns 0 on success or -1 on failure.
+ *---------------------------------------------------------------------------*/
+int ti_lidd_p_wr_or_rd(struct lidd_hal_obj *p, unsigned int cmd,
+		       unsigned int data)
+{
+
+	/* Write the character on the active hd47780 instance. */
+	hd47780_ioctl(p->lcd_inst[p->active_inst], cmd, data);
+
+	/* Update the rows and columns for the next read or write,
+	   only if enabled for line wrap. */
+
+	if (p->line_wrap)
+		ti_lidd_p_lwrap_cursor_move(p, p->cursor_shift);
+
+	return 0;
+}
+
+struct lidd_hal_obj *ti_lidd_hal_init(struct ti_lidd_info *p_lidd_info)
+{
+	static int g_lcd_inst;
+	struct lidd_hal_obj *p = NULL;
+	struct ti_lcd_cntl_regs *p_regs = NULL;
+
+	int i;
+
+	/* Initialize the controller, if not done already. */
+
+	p = kzalloc(sizeof(struct lidd_hal_obj), GFP_KERNEL);
+	if (!p)
+		return NULL;
+
+	p->regs = (struct ti_lcd_cntl_regs *)p_lidd_info->base_addr;
+
+	if (g_lcd_inst == 2) {
+		kfree(p);
+		return NULL;
+	}
+	if (g_lcd_inst == 0) {
+		p_regs = p->regs;
+		p_regs->cntl &= ~1;	/* Sets it in the HD47780 mode. */
+		p_regs->cntl &= ~(LCD_CLK_DIVISOR_MASK);
+		p_regs->cntl |= LCD_CLK_DIVISOR(0x7f);	/* modify the code here
+					for instance where mclk is required. */
+		p_regs->cs[0].config |= LCD_RS_SETUP(LCD_LIDD_P0_RS_SETUP_CYC)
+		    | LCD_RS_WIDTH(LCD_LIDD_P0_RS_DUR_CYC)
+		    | LCD_RS_HOLD(LCD_LIDD_P0_RS_HOLD_CYC);
+		p_regs->cs[1].config |= LCD_RS_SETUP(LCD_LIDD_P1_RS_SETUP_CYC)
+		    | LCD_RS_WIDTH(LCD_LIDD_P1_RS_DUR_CYC)
+		    | LCD_RS_HOLD(LCD_LIDD_P1_RS_HOLD_CYC);
+		p_regs->cs[0].config |= LCD_WS_SETUP(LCD_LIDD_P0_WS_SETUP_CYC)
+		    | LCD_WS_WIDTH(LCD_LIDD_P0_WS_DUR_CYC)
+		    | LCD_WS_HOLD(LCD_LIDD_P0_WS_HOLD_CYC);
+		p_regs->cs[1].config |= LCD_WS_SETUP(LCD_LIDD_P1_WS_SETUP_CYC)
+		    | LCD_WS_WIDTH(LCD_LIDD_P1_WS_DUR_CYC)
+		    | LCD_WS_HOLD(LCD_LIDD_P1_WS_HOLD_CYC);
+	}
+
+	p->active_inst = 0;
+	p->num_lcd_inst = p_lidd_info->num_lcd;
+	p->disp_row = p_lidd_info->disp_row;
+	p->disp_col = p_lidd_info->disp_col;
+	p->cursor_state = p_lidd_info->cursor_show;
+	p->line_wrap = p_lidd_info->line_wrap;
+	p->row = 0;
+	p->col = 0;
+	p->cursor_shift = RIGHT;
+
+	if (p_lidd_info->lcd_type == 4) {
+		p_regs->lidd_cntl &= 0xfffffff8;
+		p_regs->lidd_cntl |= 0x4;
+
+		for (i = 0; i < p->num_lcd_inst; i++) {
+			p->lcd_inst[i] =
+				hd47780_init((unsigned int)(&p_regs->cs[i +
+							g_lcd_inst].addr),
+					     (unsigned int)(&p_regs->cs[i +
+							g_lcd_inst].data),
+					  (p->disp_row / p->num_lcd_inst),
+					  (p->disp_col / p->num_lcd_inst));
+
+			if (!p->lcd_inst[i])
+				goto hd47780_init_error;
+
+			hd47780_ioctl(p->lcd_inst[i], LIDD_CURSOR_SHIFT,
+				      p->cursor_shift);
+			hd47780_ioctl(p->lcd_inst[i], LIDD_DISPLAY, ON);
+			hd47780_ioctl(p->lcd_inst[i], LIDD_CURSOR_STATE,
+				      (p->cursor_state && i == 0) ? ON : OFF);
+			hd47780_ioctl(p->lcd_inst[i], LIDD_DISPLAY_MOVE, OFF);
+			hd47780_ioctl(p->lcd_inst[i], LIDD_BLINK,
+				      (p_lidd_info->cursor_blink
+				       && i == 0) ? ON : OFF);
+			hd47780_ioctl(p->lcd_inst[i], LIDD_CLEAR_SCREEN, 0);
+
+		}
+	}
+
+	g_lcd_inst += p->num_lcd_inst;
+
+	return p;
+
+hd47780_init_error:
+	while (i > 0) {
+		hd47780_cleanup(p->lcd_inst[--i]);
+		p->num_lcd_inst--;
+	}
+	kfree(p);
+	return NULL;
+}
+
+int ti_lidd_hal_ioctl(struct lidd_hal_obj *p, unsigned int cmd,
+		      unsigned int val)
+{
+	switch (cmd) {
+	case LIDD_CLEAR_SCREEN:
+		hd47780_ioctl(p->lcd_inst[0], cmd, val);
+		if (p->num_lcd_inst > 1)
+			hd47780_ioctl(p->lcd_inst[1], cmd, val);
+		p->row = 0;
+		p->col = 0;
+		break;
+
+	case LIDD_LINE_WRAP:
+		p->line_wrap = val ? 1 : 0;
+		if (p->line_wrap) {
+			p->active_inst = 0;
+			ti_lidd_p_update_properties(p);
+
+			/* disable display shift */
+			if (p->num_lcd_inst > 1)
+				hd47780_ioctl(p->lcd_inst[1],
+					      LIDD_DISPLAY_MOVE, val);
+			hd47780_ioctl(p->lcd_inst[0], LIDD_DISPLAY_MOVE, val);
+		}
+		break;
+
+	case LIDD_CURSOR_HOME:
+		if (p->num_lcd_inst > 1) {
+			hd47780_ioctl(p->lcd_inst[1], cmd, 0);
+			hd47780_ioctl(p->lcd_inst[1], LIDD_CURSOR_STATE, 0);
+		}
+		hd47780_ioctl(p->lcd_inst[0], cmd, 0);
+		p->row = 0;
+		p->col = 0;
+		break;
+
+	case LIDD_DISPLAY:
+		if (p->num_lcd_inst > 1)
+			hd47780_ioctl(p->lcd_inst[1], cmd, val);
+		hd47780_ioctl(p->lcd_inst[0], cmd, val);
+		break;
+
+	case LIDD_GOTO_XY:
+		ti_lidd_p_set_to_xy(p, (val & 0xff00) >> 8, val & 0xff);
+		break;
+
+	case LIDD_BLINK:
+		if (p->num_lcd_inst > 1)
+			hd47780_ioctl(p->lcd_inst[1], cmd, val);
+		hd47780_ioctl(p->lcd_inst[0], cmd, val);
+		break;
+
+	case LIDD_CURSOR_STATE:
+		hd47780_ioctl(p->lcd_inst[p->active_inst], cmd, val);
+		p->cursor_state = val ? 1 : 0;
+		break;
+
+	case LIDD_CURSOR_SHIFT:
+		if (p->num_lcd_inst > 1)
+			hd47780_ioctl(p->lcd_inst[1], cmd, val);
+		hd47780_ioctl(p->lcd_inst[0], cmd, val);
+		p->cursor_shift = (val) ? 1 : 0;
+		break;
+
+	case LIDD_CURSOR_MOVE:
+		{
+			if (!p->line_wrap
+			    && !ti_lidd_p_lwrap_cursor_move(p, val))
+				hd47780_ioctl(p->lcd_inst[p->active_inst],
+					      cmd, val);
+		}
+		break;
+
+	case LIDD_DISPLAY_SHIFT:
+		if (p->num_lcd_inst > 1)
+			hd47780_ioctl(p->lcd_inst[1], cmd, val);
+		hd47780_ioctl(p->lcd_inst[0], cmd, val);
+		p->line_wrap = 0;	/* p->row = 0; p->col = 0; */
+		break;
+
+	case LIDD_DISPLAY_MOVE:
+		hd47780_ioctl(p->lcd_inst[p->active_inst], cmd, val);
+		break;
+
+	case LIDD_WR_CHAR:
+	case LIDD_RD_CHAR:
+		ti_lidd_p_wr_or_rd(p, cmd, val);
+		break;
+
+	case LIDD_RD_CMD:
+		hd47780_ioctl(p->lcd_inst[p->active_inst], cmd, val);
+		break;
+
+	default:
+		break;
+
+	}
+
+	return 0;
+}
+
+int ti_lidd_hal_open(struct lidd_hal_obj *p)
+{
+	return 0;
+}
+
+int ti_lidd_hal_close(struct lidd_hal_obj *p)
+{
+	return 0;
+}
+
+int ti_lidd_hal_write(struct lidd_hal_obj *p, char *data, unsigned int len)
+{
+	int i = 0;
+	for (i = 0; i < len; i++) {
+		/* Ignore NULLs and NLs */
+		if (!data[i] || data[i] == 0xa)
+			continue;
+		if (ti_lidd_p_wr_or_rd(p, LIDD_WR_CHAR, data[i]))
+			break;
+	}
+	return i;
+}
+
+int ti_lidd_hal_read(struct lidd_hal_obj *p, char *data, unsigned int len)
+{
+	int i = 0;
+	for (i = 0; i < len; i++) {
+		if (ti_lidd_p_wr_or_rd
+		    (p, LIDD_RD_CHAR, (unsigned int)&(data[i])))
+			break;
+	}
+	return i;
+}
+
+int ti_lidd_hal_cleanup(struct lidd_hal_obj *p)
+{
+	while (p->num_lcd_inst--)
+		hd47780_cleanup(p->lcd_inst[p->num_lcd_inst]);
+
+	kfree(p);
+
+	return 0;
+}
Index: primus-kernel/drivers/char/omapl1x7_lcd/lidd_hal.h
===================================================================
--- /dev/null
+++ primus-kernel/drivers/char/omapl1x7_lcd/lidd_hal.h
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2008 MontaVista Software Inc.
+ * Copyright (C) 2008 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+/**************************************************************************
+ * FILE PURPOSE :   HAL header for LCD LIDD controller.
+ **************************************************************************
+ * FILE NAME    :   lidd_hal.h
+ *
+ * DESCRIPTION  :
+ *  HAL code for LCD LIDD controller.
+ *
+ *************************************************************************/
+#ifndef _LIDD_HAL_H_
+#define _LIDD_HAL_H_
+
+#include "lidd_cmd.h"
+
+/* LCD controller configuration */
+
+#define LCD_LIDD_P0_RS_SETUP_CYC     1
+#define LCD_LIDD_P0_RS_HOLD_CYC      1
+#define LCD_LIDD_P0_RS_DUR_CYC       4
+
+#define LCD_LIDD_P1_RS_SETUP_CYC     1
+#define LCD_LIDD_P1_RS_HOLD_CYC      1
+#define LCD_LIDD_P1_RS_DUR_CYC       4
+
+#define LCD_LIDD_P0_WS_SETUP_CYC     1
+#define LCD_LIDD_P0_WS_HOLD_CYC      1
+#define LCD_LIDD_P0_WS_DUR_CYC       4
+
+#define LCD_LIDD_P1_WS_SETUP_CYC     1
+#define LCD_LIDD_P1_WS_HOLD_CYC      1
+#define LCD_LIDD_P1_WS_DUR_CYC       4
+
+#define LCD_CLK_DIVISOR(x)          ((x) << 8)
+#define LCD_CLK_DIVISOR_MASK        LCD_CLK_DIVISOR(0xFF)
+#define LCD_MODE_SEL_MASK           0x01
+
+#define LCD_CS1_E1_POL_INV          0x80
+#define LCD_CS0_E0_POL_INV          0x40
+#define LCD_WE_RW_POL_INV           0x20
+#define LCD_OE_E_POL_INV            0x10
+#define LCD_ALE_POL_INV             0x08
+#define LCD_LIDD_MODE(x)            ((x) << 0)
+
+#define LCD_HITACHI_MODE            0x04
+#define LCD_MPU80_ASYNC_MODE        0x03
+#define LCD_MPU80_SYNC_MODE         0x02
+#define LCD_MPU68_ASYNC_MODE        0x01
+#define LCD_MPU68_SYNC_MODE         0x00
+
+#define LCD_LIDD_MODE_MASK          LCD_LIDD_MODE(0x07)
+
+#define LCD_WS_SETUP(x)             ((x) << 27)
+#define LCD_WS_WIDTH(x)             ((x) << 21)
+#define LCD_WS_HOLD(x)              ((x) << 17)
+#define LCD_RS_SETUP(x)             ((x) << 12)
+#define LCD_RS_WIDTH(x)             ((x) << 6)
+#define LCD_RS_HOLD(x)              ((x) << 2)
+#define LCD_LIDD_DELAY(x)           ((x) << 0)
+
+#define LCD_WS_SETUP_MASK           LCD_WS_SETUP(0x1F)
+#define LCD_WS_WIDTH_MASK           LCD_WS_WIDTH(0x3F)
+#define LCD_WS_HOLD_MASK            LCD_WS_HOLD(0x0F)
+#define LCD_RS_SETUP_MASK           LCD_RS_SETUP(0x1F)
+#define LCD_RS_WIDTH_MASK           LCD_RS_WIDTH(0x3F)
+#define LCD_RS_HOLD_MASK            LCD_RS_HOLD(0x0F)
+
+#define LCD_LIDD_DELAY_MASK         LCD_LIDD_DELAY(0x03)
+
+struct ti_lidd_info {
+	unsigned int base_addr;
+	unsigned int disp_row;	/* total number of row. */
+	unsigned int disp_col;	/* total number of col. */
+	unsigned int line_wrap;	/* whether to wrap the line. */
+	unsigned int cursor_blink;
+	unsigned int cursor_show;
+	unsigned int lcd_type;	/* 0 = Sync MPU68,
+				   1 = Async MPU68,
+				   2 = Sync MPU80,
+				   3 = Aync MPU80,
+				   4 = Hitachi (Async) */
+	unsigned int num_lcd;	/* num of hd44780 or equivalnet lcd.
+				   The valid values are 1 or 2. */
+};
+
+/**********************************************************************
+ * Returns: NULL in case of error, otherwise a handle to be used in sub-
+ * sequent calls.
+ *********************************************************************/
+struct lidd_hal_obj *ti_lidd_hal_init(struct ti_lidd_info *);
+
+/**********************************************************************
+ * Returns: -1 for error otherwise 0 for success.
+ *********************************************************************/
+int ti_lidd_hal_open(struct lidd_hal_obj *);
+int ti_lidd_hal_close(struct lidd_hal_obj *);
+int ti_lidd_hal_cleanup(struct lidd_hal_obj *);
+
+/***********************************************************************
+ * Returns: -1 for error, otherwise the number of bytes that were
+ *          actually written.
+ *
+ *          The write begins at the current address location.
+ *
+ * Note: Here, the character array is not assumed to be NULL terminted.
+ *
+ **********************************************************************/
+int ti_lidd_hal_write(struct lidd_hal_obj *, char *, unsigned int size);
+
+/***********************************************************************
+ * Returns: -1 for error, otherwise the number of bytes that were
+ *          read.
+ *
+ *          The read begins at the current address location.
+ *
+ * Note: Here, the character array is not assumed to be NULL terminted.
+ *
+ **********************************************************************/
+int ti_lidd_hal_read(struct lidd_hal_obj *, char *, unsigned int size);
+
+/**********************************************************************
+ * Returns: -1 for error, other 0 for success.
+ *
+ *     cmd                                  val
+ *
+ *     TI_LIDD_CLEAR_SCREEN                 none
+ *     TI_LIDD_CURSOR_HOME                  none
+ *     TI_LIDD_DISPLAY                      0 - off, 1 - on
+ *     TI_LIDD_GOTO_XY                      [row - 2 bytes][col - 2 bytes]
+ *     TI_LIDD_BLINK                        0 - off, 1 - on
+ *     TI_LIDD_CURSOR_STATE                 0 - not visible, 1 - visible.
+ *     TI_LIDD_SHIFT                        1 - Right shift, 0 - left shift.
+ *     TI_LIDD_CURSOR_SHIFT                 1 - Right, 0 - left
+ *     TI_LIDD_WR_CHAR                      character.
+ *     TI_LIDD_RD_CHAR                      place holder for character.
+ *     TI_LIDD_CURSOR_MOVE                  1 - Right, 0 - Left
+ *     TI_LIDD_DISPLAY_MOVE                 1 - Right, 0 - Left.
+ *     TI_LIDD_LINE_WRAP                    0 - off, 1 - on.
+ *
+ *********************************************************************/
+int ti_lidd_hal_ioctl(struct lidd_hal_obj *, unsigned int cmd,
+		      unsigned int val);
+
+#endif				/* _LIDD_HAL_H_ */
Index: primus-kernel/drivers/char/Makefile
===================================================================
--- primus-kernel.orig/drivers/char/Makefile
+++ primus-kernel/drivers/char/Makefile
@@ -111,6 +111,8 @@ obj-$(CONFIG_PS3_FLASH)		+= ps3flash.o
 obj-$(CONFIG_JS_RTC)		+= js-rtc.o
 js-rtc-y = rtc.o
 
+obj-$(CONFIG_OMAPL1X7_LCD)	+= omapl1x7_lcd/
+
 # Files generated that shall be removed upon make clean
 clean-files := consolemap_deftbl.c defkeymap.c
 
Index: primus-kernel/drivers/char/omapl1x7_lcd/lidd_cmd.h
===================================================================
--- /dev/null
+++ primus-kernel/drivers/char/omapl1x7_lcd/lidd_cmd.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2008 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+/**************************************************************************
+ *
+ *  FILE DESCRIPTION  :
+ *  IOCTL commands for LCD LIDD controller.
+ *
+ *************************************************************************/
+
+#ifndef _LIDD_CMD_H_
+#define _LIDD_CMD_H_
+
+#define LIDD_CLEAR_SCREEN   1
+#define LIDD_CURSOR_HOME    2
+#define LIDD_GOTO_XY        3
+#define LIDD_DISPLAY        4
+#define LIDD_BLINK          5
+#define LIDD_CURSOR_STATE   6
+#define LIDD_DISPLAY_SHIFT  7
+#define LIDD_CURSOR_SHIFT   8
+#define LIDD_CURSOR_MOVE    9
+#define LIDD_DISPLAY_MOVE   10
+#define LIDD_WR_CHAR        11
+#define LIDD_RD_CHAR        12
+#define LIDD_LINE_WRAP      13
+#define LIDD_RD_CMD         14
+
+#define RIGHT                1
+#define LEFT                 0
+#define ON                   1
+#define OFF                  0
+
+#endif				/* _LIDD_CMD_H_ */
